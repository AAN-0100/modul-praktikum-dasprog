\section*{Tujuan}
\begin{itemize}[label=$\bullet$, itemsep=-1pt, leftmargin=*]
	\item Mahasiswa mengenal dan mampu menggunakan ekspresi-ekspresi logika dan perbandingan pada bahasa pemrograman C
	\item Mahasiswa mengenal dan mampu menggunakan syntax-syntax percabangan pada bahasa pemrograman C
	\item Mahasiswa dapat mengenal dan menggunakan perulangan while pada bahasa C
	      % \item Students are able to use while-loop on C
	\item Mahasiswa dapat mengenal dan menggunakan perulangan do-while pada bahasa C
	      % \item Students are able to use do-while loop on C
	\item Mahasiswa dapat mengenal dan menggunakan perulangan for pada bahasa C
	      % \item Students are able to use for loop on C
	\item Mahasiswa dapat mengenal dan menggunakan  array dimensi satu maupun multidimensi.
	      % \item Students are able to use one dimensional or multidimensional array
	\item Mahasiswa mampu memanfaatkan perulangan untuk mengolah data pada array.
	      % \item Students are able to use loops to process data on arrays
	\item Mahasiswa  dapat mengenal dan menggunakan  string.
\end{itemize}

\section{percabangan}

pada modul sebelumnya kita sudah mempelajari tentang operator pembanding dan operator logika.
Kedua operator ini akan sering digunakan dalam percabangan.
\begin{center}
\captionof{table}{Operator Relasional\label{tab:relasional}}
\begin{tabular}{|c|c|c|}
\hline
\textbf{Simbol} & \textbf{Nama Operator} & \textbf{Contoh Sintaks} \\ \hline
<    & Kurang dari 					& a < b  \\ \hline
<=   & Kurang dari atau sama dengan & a <= b \\ \hline
>    & Lebih dari 					& a > b  \\ \hline
>=   & Lebih dari atau sama dengan 	& a >= b \\ \hline
==   & Sama dengan 					& a == b \\ \hline
!=   & Tidak sama dengan 			& a != b \\ \hline
\end{tabular}
\captionof{table}{Operator Logika\label{tab:logika}}
\begin{tabular}{|c|c|c|}
\hline
\textbf{Simbol} & \textbf{Nama Operator} & \textbf{Contoh Sintaks} \\ \hline
\&\&	& AND 	& \verb|a && b| \\ \hline
||   	& OR 	& \verb!a || b! \\ \hline
!=    	& NOT 	& \verb|a != b| \\ \hline
\end{tabular}
\end{center}

\subsection{Pernyataan if}

Pernyataan if digunakan untuk menentukan apakah sebuah blok kode dijalankan atau tidak tergantung pada sebuah kondisi.
Jika kondisinya true, maka blok kode akan dijalankan jika false maka tidak dijalankan.
if bisa ditulis seperti berikut
{
\captionsetup[lstlisting]{labelformat=empty, justification=raggedright, singlelinecheck=false} %agar caption tanpa label dan di kiri
\begin{lstlisting}[language=c, caption={syntax}]
	if(kondisi){
		//kode yang dijalankan jika kondisi true
	}
\end{lstlisting}
}
Contoh:
\begin{lstlisting}[language=c]
#include <stdio.h>

int main() {
	int angka = 5;

	if (angka > 0) {
		printf("Angka %d adalah positif\n", angka);
	}

	return 0;
}
\end{lstlisting}
\begin{verbatim}
    Output:
    Angka 5 adalah positif
\end{verbatim}

\subsection{Pernyataan if-else}

Pernyataan else digunakan untuk menentukan blok kode yang dijalankan jika kondisi false.
{
\captionsetup[lstlisting]{labelformat=empty, justification=raggedright, singlelinecheck=false} %agar caption tanpa label dan di kiri
\begin{lstlisting}[language=c, caption={syntax}]
	if (kondisi) {
		// kode yang dijalankan jika true
	} else {
		// kode yang dijalankan jika false
	}
\end{lstlisting}
}
Contoh:
\begin{lstlisting}[language=c]
#include <stdio.h>

int main() {
	int angka = -5;

	if (angka > 0) {
		printf("Angka %d adalah positif\n", angka);
	}
	else {
		printf("Angka %d tidak positif\n", angka);
	}

	return 0;
}
\end{lstlisting}
\begin{verbatim}
	Output:
	Angka -5 tidak positif
\end{verbatim}

\subsection{Pernyataan if-else if}

Pernyataan else if digunakan untuk menentukan kondisi baru jika kondisi sebelumnya false.
Pernyataan ini bisa digunakan jika terdapat banyak kondisi dengan hasil yang berbeda-beda.
{
\captionsetup[lstlisting]{labelformat=empty, justification=raggedright, singlelinecheck=false} %agar caption tanpa label dan di kiri
\begin{lstlisting}[language=c, caption={syntax}]
	if (kondisi1) {
		  // kode yang dijalankan jika kondisi1 true
		} else if (kondisi2) {
		  // kode yang dijalankan jika kondisi1 false, dan kondisi2 true
		} else {
		  // kode yang dijalankan jika semua kondisi di atas salah
		}
\end{lstlisting}
}
Contoh:
\begin{lstlisting}[language=c]
#include <stdio.h>

int main() {
	int angka = -3;

	if (angka > 0) {
		printf("Angka %d adalah positif\n", angka);
	}
	else if(angka < 0){
		printf("Angka %d adalah negatif\n", angka);
	}
	else{
		printf("Angka %d adalah 0\n", angka);
	}

	return 0;
}
\end{lstlisting}
\begin{verbatim}
	Output:
	Angka -3 adalah negatif
\end{verbatim}

\subsection{Nested if}

Nested if adalah konsep dimana terdapat pernyataan if di dalam pernyataan if
\\ Contoh:
\begin{lstlisting}[language=c]
#include <stdio.h>

int main() {
	int angka = 3;

	if (angka > 0) {
		if(angka % 2 == 0){
			printf("Angka %d adalah genap");
		}
		else{
			printf("Angka %d adalah ganjil");
		}
	}
	else{
		printf("Angka %d tidak positif");
	}

	return 0;
}
\end{lstlisting}
\begin{verbatim}
	Output:
	Angka 3 adalah ganjil
\end{verbatim}

\subsection{Operator Kondisional}
Kita sudah mempelajari terkait operator pada modul sebelumnya.
Disebutkan bahwa operator kondisional bisa digunakan sebagai pengganti if.
Operator ini bisa membuat penulisan beberapa baris kode menjadi satu baris saja.
{
\captionsetup[lstlisting]{labelformat=empty, justification=raggedright, singlelinecheck=false} %agar caption tanpa label dan di kiri
\begin{lstlisting}[language=c, caption={syntax}]
	variabel = kondisi ? nilai_jika_benar : nilai_jika_salah;
\end{lstlisting}
}
Contoh 1:
\\ Jika menggunakan if kita akan tulis seperti ini:
\begin{lstlisting}[language=c]
	int angka = 4;
	if (angka % 2 == 0) {
		printf("Genap");
	} else {
		printf("Ganjil");
	}
\end{lstlisting}
Jika menggunakan operator kondisional bisa ditulis seperti ini:
\begin{lstlisting}[language=c]
	int angka = 4;
    (angka % 2 == 0) ? printf("Genap") : printf("Ganjil");
\end{lstlisting}

Contoh 2:
\\ Jika menggunakan if:
\begin{lstlisting}[language=c]
	int a = 5, b = 3, max;

	if(a>b){
		max = a;
	}
	else{
		max = b;
	}

	printf("Nilai terbesar adalah: %d\n", max);
\end{lstlisting}
Bisa ditulis sebagai:
\begin{lstlisting}[language=c]
	int a = 5, b = 3, max;

	max = (a > b) ? a : b;

	printf("Nilai terbesar adalah: %d\n", max);

	return 0;
\end{lstlisting}

\subsection{Switch}
Pernyataan switch bisa digunakan sebagai alternatif dari if-else if.
Switch bagus digunakan ketika kita memiliki satu variabel dengan nilai terbatas atau diskret (seperti int atau char) 
dan ingin mengeksekusi salah satu dari beberapa blok kode alternatif.
{
\captionsetup[lstlisting]{labelformat=empty, justification=raggedright, singlelinecheck=false} %agar caption tanpa label dan di kiri
\begin{lstlisting}[language=c, caption={syntax}]
	switch (ekspresi) {
		case x:
			// kode yang dijalankan jika nilai ekspresi adalah x
			break;
		case y:
			// kode yang dijalankan jika nilai ekspresi adalah y
			break;
		default:
			// kode yang dijalankan jika nilai ekspresi tidak ada yang sama dengan setiap case di atas
		}
\end{lstlisting}
}
Contoh:
\begin{lstlisting}[language=c]
	int hari = 4;

    switch (hari) {
		case 1:
			printf("Senin");
			break;
		case 2:
			printf("Selasa");
			break;
		case 3:
			printf("Rabu");
			break;
		case 4:
			printf("kamis");
			break;
		case 5:
			printf("Jumat");
			break;
		case 6:
			printf("Sabtu");
			break;
		case 7:
			printf("Minggu");
			break;
    }
\end{lstlisting}
\begin{verbatim}
	Output:
	kamis
\end{verbatim}

\subsection*{Tugas Pendahuluan 1}
\begin{enumerate}
	\item Ketika menulis pernyataan if-else if, urutan penulisan kondisi bisa mempengaruhi jalannya program.
	Mengapa demikian? Apa yang terjadi jika urutannya salah? Berikan contoh kasus ketika itu terjadi!
	\item Buatlah program yang menerima input 3 buah bilangan bulat A, B, dan C.
	Outputkanlah 3 bilangan bulat itu ke layar dengan urutan paling besar ke paling kecil. 
	Gunakanlah statement if, if else, if else if, atau nested if.
	\item Perhatikan kode berikut
	\begin{lstlisting}[language=c]
	float angka = 3.14;
	switch(angka) {
		case 3.14:
			printf("Pi\n");
			break;
	}
\end{lstlisting}
	Apa yang terjadi ketika kode di atas dijalankan?
	Kenapa hal itu terjadi?
\end{enumerate}

\section{Perulangan}

Perulangan (looping) adalah proses mengeksekusi suatu blok kode berulang kali selama kondisi tertentu terpenuhi.
Tujuannya untuk menghindari penulisan kode berulang secara manual.

\subsection{Perulangan while}
Perulangan while akan terus menjalankan kodenya selama kondisinya benar.
{
\captionsetup[lstlisting]{labelformat=empty, justification=raggedright, singlelinecheck=false} %agar caption tanpa label dan di kiri
\begin{lstlisting}[language=c, caption={syntax}]
	while(kondisi){
		// kode yang dijalankan berulang selama kondisi benar
	}
\end{lstlisting}
}
Contoh:
\begin{lstlisting}[language=c]
	int i = 0;
	
	while (i < 10) {
		printf("%d\n", i);
		i++;
	}
\end{lstlisting}
\begin{verbatim}
	Output:
    0
    1
    2
    3
    4
    5
    6
    7
    8
    9
\end{verbatim}
Pada contoh di atas kode akan berulang selama nilai i kurang dari 10, sehingga ketika nilai i mencapai nilai 10 perulangan berhenti.

\subsection{Perulangan do-while}

Perulangan ini sama seperti perulangan while, tetapi blok kodenya akan dijalankan sekali sebelum mengecek kondisi.
{
\captionsetup[lstlisting]{labelformat=empty, justification=raggedright, singlelinecheck=false} %agar caption tanpa label dan di kiri
\begin{lstlisting}[language=c, caption={syntax}]
	do{
		// kode yang dijalankan sekali, lalu cek jika perlu dijalankan lagi
	} while(kondisi);
\end{lstlisting}
}
Contoh:
\begin{lstlisting}[language=c]
	int i = 3;

	do {
		printf("%d\n", i);
		i++;
	}
	while (i < 3);
\end{lstlisting}
\begin{verbatim}
	Output:
	3
\end{verbatim}
Contoh di atas outputnya adalah 3, meskipun kondisinya adalah i<3 yang mana bernilai salah, karena kode dijalankan sekali sebelum mengecek kondisi.

\subsection{Perulangan for}

Perulangan for digunakan jika kita tahu berapa kali perulangan yang perlu dilakukan.
{
\captionsetup[lstlisting]{labelformat=empty, justification=raggedright, singlelinecheck=false} %agar caption tanpa label dan di kiri
\begin{lstlisting}[language=c, caption={syntax}]
	for (ekspresi1; ekspresi2; ekspresi3) {
		// kode yang akan diulang
	}
\end{lstlisting}
}
Syntax di atas bisa juga ditulis dengan perulangan while menjadi:
{
\captionsetup[lstlisting]{labelformat=empty, justification=raggedright, singlelinecheck=false} %agar caption tanpa label dan di kiri
\begin{lstlisting}[language=c, caption={syntax}]
	ekspresi1;
	while(ekspresi2){
		// blok kode yang akan diulang
		ekspresi3;
	}
\end{lstlisting}
}
\begin{enumerate}[label={}, leftmargin=*]
	\item ekspresi1 : dieksekusi sekali sebelum perulangan dimulai
	\item ekspresi2 : kondisi yang perlu dipenuhi agar perulangan berjalan.
	\item ekspresi3 : dieksekusi pada setiap perulangan setelah blok kode dieksekusi
\end{enumerate}
Contoh 1:
\begin{lstlisting}[language=c]
	for (int i = 0; i < 5; i++) {
		printf("%d\n", i);
	}
\end{lstlisting}
\begin{verbatim}
	Output:
	0
	1
	2
	3
	4
\end{verbatim}
Contoh di atas perulangan terjadi sebanyak 5 kali.
Karena "int i=0" berarti nilai awal i adalah 0,
Lalu "i++" berarti nilai i selalu bertambah 1 di setiap akhir perulangan,
Sehingga ketika nilai i=5 nilai i tidak memenuhi kondisi "i<5" membuat perulangan berhenti.
\\ Contoh 2:
\begin{lstlisting}[language=c]
	for (int i = 0; i <= 10; i = i + 2) {
		rintf("%d\n", i);
	}
\end{lstlisting}
\begin{verbatim}
	Output:
	0
	2
	4
	6
	8
	10
\end{verbatim}
Contoh di atas perulangan terjadi sebanyak 6 kali.
Karena "int i=0" berarti nilai awal i adalah 0,
Lalu "i=i+2" berarti nilai i selalu bertambah 2 di setiap akhir perulangan,
Sehingga ketika nilai i=12 nilai i tidak memenuhi kondisi "i<=10" membuat perulangan berhenti.

\subsection{Nested Loop}

Nested loop adalah konsep dimana sebuah perulangan berada di dalam perulangan lain.
\\ Contoh :
\begin{lstlisting}[language=c]
	for (int i = 0; i < 3; i++) {
		for (int j = 0; j < 2; j++) {
			printf("i = %d, j = %d\n", i, j);
		}
	}
\end{lstlisting}
\begin{verbatim}
	output:
	i = 0, j = 0
	i = 0, j = 1
	i = 1, j = 0
	i = 1, j = 1
	i = 2, j = 0
	i = 2, j = 1
\end{verbatim}
Perulangan di luar yang menggunakan variabel "i", berulang sebanyak 3 kali.
Perulangan di dalam yang menggunakan variabel "j", berulang sebanyak 2 kali.
Setiap iterasi "i", perulangan "j" akan berjalan sepenuhnya. sehingga:
\begin{enumerate}[label={}, leftmargin=*]
	\item saat i=0 \\
	j=0 -> print i=0, j=0 \\
	j=1 -> print i=0, j=1
	\item saat i=1 \\
	j=0 -> print i=1, j=0 \\
	j=1 -> print i=1, j=1
	\item saat i=2 \\
	j=0 -> print i=2, j=0 \\
	j=1 -> print i=2, j=1
\end{enumerate}

\subsection{Break dan Continue}

\subsubsection{Break}

Kita sudah melihat pernyataan break pada sub-bab percabangan bagian switch.
Disini break digunakan untuk keluar dari pernyataan switch.
Break juga bisa digunakan untuk keluar dari perulangan sehingga perulangan berhenti.
\\ Contoh:
\begin{lstlisting}[language=c]
	for (int i = 0; i < 5; i++) {
		if (i == 3) {
			break;  
		}
		printf("%d ", i);
	}
\end{lstlisting}
\begin{verbatim}
	output:
	0 1 2
\end{verbatim}
Pada contoh di atas perulangan terjadi dari i=0 hingga i=4, tetapi ketika iterasi i=3 perulangan berakhir karena pernyataan break.

\subsubsection{Continue}

Jika pernyataan break membuat sebuah perulangan berhenti.
Pernyataan continue hanya membuat iterasi saat itu berhenti.
Contoh:
\begin{lstlisting}[language=c]
	for (int i = 0; i < 5; i++) {
		if (i == 3) {
			continue;
		}
		printf("%d ", i);
	}
\end{lstlisting}
\begin{verbatim}
	output:
	0 1 2 4
\end{verbatim}
Pada contoh di atas iterasi ketika i=3 dilewati dan masih melanjutkan ke iterasi berikutnya

\subsection*{Tugas Pendahuluan 2}
\begin{enumerate}
	\item Perhatikan kode berikut:
	\begin{lstlisting}[language=c]
	for(;;){
		printf("B300 MIOT\n");
	}	
\end{lstlisting}
	Apa yang terjadi jika program tersebut dijalankan? Kenapa hal itu bisa terjadi?
	\item Perhatikan dua kode berikut:
	\begin{lstlisting}[language=c]
	for(int i=0;i<100;i++){
		break;
	}
\end{lstlisting}
\begin{lstlisting}[language=c]
	for(int i=0;i<100;i++){
		continue;
	}
\end{lstlisting}
Apa yang terjadi jika kedua kode di atas dijalankan?
Jika kamu harus memilih diantara kedua kode di atas, kode mana yang akan kamu pilih? Kenapa?
	\item Perhatikan kode berikut:
	\begin{lstlisting}[language=c]
	for(int i=0;i<10;i++){
		for(int j=i;j>=0;j--){
			printf("B300\n");
		}
	}
\end{lstlisting}
Ketika Perulangan di atas dijalankan, berapa banyak "B300" yang muncul di output?
	\item Buatlah program dalam bahasa C untuk mendapatkan semua bilangan kuadrat antara 1 sampai 100!
\end{enumerate}

\section{Array}

Array adalah kumpulan data dengan tipe data yang sama yang disimpan dalam satu blok memori berurutan.
Dengan array, kita bisa menyimpan banyak data tanpa perlu membuat banyak variabel satu per satu.
Untuk mendeklarasikan array, kita bisa deklarasikan dengan cara yang mirip ketika mendeklarasikan variabel.
{
\captionsetup[lstlisting]{labelformat=empty, justification=raggedright, singlelinecheck=false} %agar caption tanpa label dan di kiri
\begin{lstlisting}[language=c, caption={syntax}]
	tipe_data nama[ukuran];
\end{lstlisting}
}
Contoh:
\begin{lstlisting}[language=c]
	int angka[5]; // array yang berisi 5 buah integer
	float nilai[10]; // array yang berisi 10 buah bilangan desimal
	char huruf[20]; // array yang berisi 20 karakter
\end{lstlisting}

\subsection{Inisialisasi Array}

Kita bisa inisialisasi array ketika deklarasi, sama seperti variabel.
Elemen dalam array, tidak bisa memiliki tipe data yang berbeda.
\begin{lstlisting}[language=c]
	int angka[5] = {1, 3, 5, 7, 9};
\end{lstlisting}
Jika inisialisasi dilakukan saat deklarasi, kita bisa tidak menuliskan ukuran.
Compiler akan menyesuaikan jumlah dari elemen yang diinisialisasi.
\begin{lstlisting}[language=c]
	int angka[] = {1, 4, 7, 10, 13, 16};
\end{lstlisting}
Array di atas secara otomatis berukuran 6.

\subsection{Mengakses Elemen Array}

Untuk mengakses elemen dalam array, kita bisa memanggil nama array dan index dari elemen yang ingin diakses.
Contoh:
\begin{lstlisting}[language=c]
	int angka[5] = {10, 20, 30, 40, 50};

	printf("%d\n", angka[0]); //mengakses array angka indek ke-0
\end{lstlisting}
'Ingat index pada array dimulai dari angka 0, sehingga pada contoh di atas, angka 10 berada pada index 0, angka 20 berada pada index 1, dst'

\subsection{Mengubah Elemen Array}

Untuk mengubah elemen dalam array, bisa dilakukan dengan mengakses array tersebut dan menggunakan operator penugasan untuk memasukkan nilai.
Contoh:
\begin{lstlisting}[language=c]
	int angka[5] = {10, 20, 30, 40, 50};
	
	angka[0] = 15; // mengubah index ke-0 menjadi 15
	
	printf("%d\n", angka[0]);
\end{lstlisting}

\subsection{Perulangan dalam Array}
Kita bisa menggunakan perulangan untuk mengakses setiap elemen yang ada dalam array satu-persatu secara berurutan.
Contoh:
\begin{lstlisting}
	int angka[5] = {1, 2, 3, 4, 5};

	for(int i = 0; i < 5; i++) {
		printf("angka[%d] = %d\n", i, angka[i]);
	}
\end{lstlisting}
\begin{verbatim}
	Output:
	angka[0] = 1
	angka[1] = 2
	angka[2] = 3
	angka[3] = 4
	angka[4] = 5
\end{verbatim}

\subsection{Ukuran Array}

Kita sudah tahu ukuran array adalah jumlah elemen yang bisa disimpan oleh sebuah array.
Untuk mendapatkan nilai ukuran dari array yang ada kita bisa menggunakan sizeof().
Contoh:
\begin{lstlisting}[language=c]
	int angka[5] = {2, 4, 8, 12, 16};
	
	int ukuran = sizeof(angka)/sizeof(angka[0]); // mendapatkan ukuran array angka
	printf("%d", ukuran);
\end{lstlisting}
Kita bisa menggunakan sizeof() untuk perulangan, sehingga perulangan bisa dilakukan dengan array ukuran berapapun.
Contoh:
\begin{lstlisting}[language=c]
	int angka[5] = {2, 4, 8, 12, 16};

	int ukuran = sizeof(angka)/sizeof(angka[0]);
	for(int i=0;i<ukuran;i++){
		printf("%d ", angka[i]);
	}
\end{lstlisting}
Pada contoh di atas, kita menggunakan variabel ukuran dari pada sebuah angka konstan.

\subsection{Array Multidimensi}

Array yang kita pelajari sejauh ini adalah array 1D.
Secara simpel array multidimensi adalah sebuah array di dalam array.
Biasanya digunakan untuk menyimpan data yang membutuhkan lebih dari 1 index, seperti data dalam tabel yang memiliki baris dan kolom.
Untuk mendeklarasikan array multidimensi dengan cara:
{
\captionsetup[lstlisting]{labelformat=empty, justification=raggedright, singlelinecheck=false} %agar caption tanpa label dan di kiri
\begin{lstlisting}[language=c, caption={syntax}]
	int nama[ukuran_1][ukuran_2]...[ukuran_n];
\end{lstlisting}
}

\subsubsection{Array 2D}

Bisa disebut sebagai matriks (memiliki baris dan kolom).
\begin{enumerate}[label={}, leftmargin=*]
	\item \textbf{Mengakses Elemen Array 2D}\\
	Untuk mengakses array 2D kita bisa lakukan dengan cara yang sama seperti array 1d
	Contoh:
	\begin{lstlisting}[language=c]
	int matrix[2][3] = { {1, 4, 2}, {3, 6, 8} };

	printf("%d", matrix[0][2]);  // output: 2
\end{lstlisting}
	\item \textbf{Mengubah Elemen Array 2D}
	\begin{lstlisting}[language=c]
	int matrix[2][3] = { {1, 4, 2}, {3, 6, 8} };

	matrix[0][2] = 5;

	printf("%d", matrix[0][2]);  // output: 5
\end{lstlisting}
	\item \textbf{Perulangan Pada Array 2d}\\
	Perulangan bisa dilakukan menggunakan nested loop
	Contoh:
	\begin{lstlisting}[language=c]
	int matrix[2][3] = { {1, 4, 2}, {3, 6, 8} };

	int i, j;
	for (i = 0; i < 2; i++) {
		for (j = 0; j < 3; j++) {
			printf("%d\n", matrix[i][j]);
		}
	}
\end{lstlisting}
\end{enumerate}

\subsubsection{Array 3D}

Array 3D bisa dibayangkan seperti kumpulan matriks (2D) yang disusun bertumpuk.
Jadi kita butuh 3 indeks untuk mengakses sebuah elemen.
Array 3D biasanya digunakan untuk data yang membutuhkan koordinat 3 dimensi.
Contoh:
\begin{lstlisting}[language=c]
	int cube[2][2][2] = {
		{ {1, 2}, {3, 4} },
		{ {5, 6}, {7, 8} }
	};
\end{lstlisting}
Untuk mengakses dan mengubah elemen dalam array 3D caranya sama seperti pada array biasanya.

\subsection*{Tugas Pendahuluan 3}
\begin{enumerate}
	\item Perhatikan kode berikut:
	\begin{lstlisting}[language=c]
	int arr[5] = {1, 2, 3, 4, 5};

	printf("%d", arr[-1]);
\end{lstlisting}
Apa yang terjadi ketika kode di atas dijalankan? Jelaskan kenapa hal itu terjadi!
	\item Perhatikan kode berikut:
	\begin{lstlisting}[language=c]
	int arr[3] = {0};
	
	printf("%d", arr[3]);
\end{lstlisting}
Apa yang terjadi ketika kode di atas dijalankan? Jelaskan kenapa hal itu terjadi!
	\item Buatlah sebuah program sederhana dimana terdapat array yang menyimpan angka 1 hingga 1000!

\end{enumerate}

\section{String}

String adalah tipe data yang digunakan untuk menyimpan teks/karakter.
Contohnya, \verb|"Halo Dunia"| adalah sebuah string.
Dalam bahasa C string adalah sebuah array dari banyak karakter yang diakhiri dengan \verb|\0| (karakter null).
Contoh:
\begin{lstlisting}[language=c]
	char kata[] = "Halo Dunia";
\end{lstlisting}
'perhatikan bahwa penulisan string menggunakan tanda kutip ganda ("")'

\subsection{Input dan Output String}
Kita bisa menggunakan printf() dan scanf() dengan specifier \verb|%s|.
Contoh 1:
\begin{lstlisting}[language=c]
	char kata[] = "Halo Dunia";

	printf("%s\n", kata);
\end{lstlisting}
\begin{verbatim}
	output:
	Halo Dunia
\end{verbatim}
Contoh 2:
\begin{lstlisting}[language=c]
	char nama[20];

	scanf("%s", nama); // input tanpa spasi

	printf("Halo, %s!\n", nama);
\end{lstlisting}
\begin{verbatim}
	output:
	B300
	Halo, B300!
\end{verbatim}
Jika kita menggunakan \verb|scanf("%s", ...);| kita hanya bisa memberi input tanpa spasi.
sehingga jika pada contoh input di atas kita memasukkan "B300 MIoT", yang terbaca hanyalah "B300";
Agar kita bisa memasukkan input dengan banyak kata (ada spasi), 
kita bisa menggunakan scanf() dengan specifier \verb|%[^\n]s| (specifier ini membuat scanf membaca hingga akhir baris)
Contoh:
\begin{lstlisting}[language=c]
	char str[20];

	scanf("%[^\n]s", str);

	printf("%s", str);
\end{lstlisting}
\begin{verbatim}
	Input:
	B300 MIoT

	Output:
	B300 MIoT
\end{verbatim}
Selain menggunakan scanf kita juga bisa menggunakan fgets() untuk membaca 1 baris input.
\begin{lstlisting}[language=c]
	char str[20];

	fgets(str, sizeof(str), stdin);

	printf("%s", str);
\end{lstlisting}
\begin{verbatim}
	Input:
	B300 luar biasa

	Output:
	B300 luar biasa
\end{verbatim}

\subsection{Fungsi-Fungsi String}
Dalam bahasa C terdapat beberapa fungsi string yang berguna untuk melakukan operasi pada sebuah string.
Untuk menggunakan fungsi-fungsi tersebut kita harus memasukkan header:
\begin{lstlisting}[language=c]
	#include <string.h>
\end{lstlisting}

\subsubsection{strlen()}
Digunakan untuk mendapatkan panjang dari sebuah string.
Contoh:
\begin{lstlisting}[language=c]
	char string[] = "B300";

	printf("%d", strlen(string));
\end{lstlisting}
\begin{verbatim}
	Output:
	4
\end{verbatim}

\subsubsection{strcpy()}
Digunakan untuk menyalin (copy) sebuah string ke variabel string lain.
Contoh:
\begin{lstlisting}[language=c]
	char src[] = "miot";
	char dest[20];
	
	strcpy(dest, src);  // menyalin string "miot" ke variabel dest
	printf("%s", dest);
\end{lstlisting}
\begin{verbatim}
	Output:
	miot
\end{verbatim}

\subsubsection{strcat()}
Digunakan untuk menggabungkan dua buah string.
Contoh:
\begin{lstlisting}[language=c]
	char s1[30] = "B300 ";
	char s2[] = "MIoT";
	
	strcat(s1, s2); menggabungkan "B300 " dengan "MIoT"
	printf("%s", s1);
\end{lstlisting}
\begin{verbatim}
	output:
	B300 MIoT	
\end{verbatim}

\subsubsection{strcmp()}
Digunakan untuk membandingkan dua string.
Fungsi ini akan mengembalikan nilai 0 ketika kedua string sama.
Contoh:
\begin{lstlisting}[language=c]
	char s1[] = "Apple";
	char s2[] = "Apple";
	
	int res = strcmp(s1, s2);

	if(res==0){
		printf("kedua string sama");
	}
	else{
		printf("string berbeda");
	}
\end{lstlisting}
Masih banyak fungsi string yang bisa kalian pelajari.
Kalian bisa mencari dokumentasi <string.h> untuk mempelajari lebih banyak fungsinya.

\subsection*{Tugas Pendahuluan 4}
\begin{enumerate}
	\item Mengapa dalam bahasa C, string harus mempunyai karakter null '\verb|\0|'? Apa yang terjadi jika sebuah string tidak memiliki karakter null '\verb|\0|'?
	\item Perhatikan kode berikut:
	\begin{lstlisting}[language=c]
	char lab[] = {'B', '3', '0', '0', ' ', 'M', 'I', 'O', 'T', '\0'};
	
	for(int i=0;i<sizeof(lab);i++){
		printf("%c", lab[i]);
	}	
\end{lstlisting}
Cobalah kode di atas! Bagaimana pendapatmu terkait kode di atas? Apakah efisien?
	\item buatlah program sederhana yang meneremima input \verb|nama_lengkap|, \verb|NRP|, dan \verb|password| dan mengecek apakah passwordnya adalah "B300 MIOT".
	Jika passwordnya benar maka mengeluarkan output:
	\begin{verbatim}
		Halo, nama_lengkap dengan NRP
		Kamu telah masuk
	\end{verbatim}
	Jika passwordnya salah maka outputnya:
	\begin{verbatim}
		Halo, nama_lengkap dengan NRP
		Kamu tidak bisa masuk
	\end{verbatim}
\end{enumerate}