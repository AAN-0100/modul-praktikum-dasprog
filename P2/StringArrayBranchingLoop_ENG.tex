\section*{Goals}
\begin{itemize}[label=$\bullet$, itemsep=-1pt, leftmargin=*]
	\item Students are familiar with and able to use logical and comparison expressions in the C programming language.
	\item Students are familiar with and able to use logical and comparison expressions in the C programming language.
	\item Students can recognize and use while loops in the C language.
	      % \item Students are able to use while-loop on C
	\item Students can recognize and use do-while loops in the C language.
	      % \item Students are able to use do-while loop on C
	\item Students can recognize and use for loops in the C language.
	      % \item Students are able to use for loop on C
	\item Students can recognize and use for loops in the C language.
	      % \item Students are able to use one dimensional or multidimensional array
	\item Students can recognize and use for loops in the C language.
	      % \item Students are able to use loops to process data on arrays
	\item Students can recognize and use strings.
\end{itemize}

\section{Branching}

In the previous module, we learned about comparison operators and logical operators.  
These operators are frequently used in branching statements.\\

\begin{center}
\captionof{table}{Relational Operators\label{tab:relasional}}
\begin{tabular}{|c|c|c|}
\hline
\textbf{Symbol} & \textbf{Operator Name} & \textbf{Example Syntax} \\ \hline
<    & Less than                & a < b  \\ \hline
<=   & Less than or equal to    & a <= b \\ \hline
>    & Greater than             & a > b  \\ \hline
>=   & Greater than or equal to & a >= b \\ \hline
==   & Equal to                 & a == b \\ \hline
!=   & Not equal to             & a != b \\ \hline
\end{tabular}

\captionof{table}{Logical Operators\label{tab:logika}}
\begin{tabular}{|c|c|c|}
\hline
\textbf{Symbol} & \textbf{Operator Name} & \textbf{Example Syntax} \\ \hline
\&\&    & AND  & \verb|a && b| \\ \hline
||      & OR   & \verb|a || b| \\ \hline
!       & NOT  & \verb|!a| \\ \hline
\end{tabular}
\end{center}

\subsection{if Statement}

The \verb|if| statement is used to determine whether a block of code executes based on a condition.  
If the condition is true, the block runs; if false, it does not.  
The syntax is:

{
\captionsetup[lstlisting]{labelformat=empty, justification=raggedright, singlelinecheck=false}
\begin{lstlisting}[language=c, caption={Syntax}]
    if(condition){
        // code executed if condition is true
    }
\end{lstlisting}
}

Example:
\begin{lstlisting}[language=c]
#include <stdio.h>

int main() {
	int number = 5;

	if (number > 0) {
		printf("Number %d is positive\n", number);
	}

	return 0;
}
\end{lstlisting}
\begin{verbatim}
Output:
Number 5 is positive
\end{verbatim}

\subsection{if-else Statement}

The \verb|else| statement determines the block executed if the condition is false.

{
\captionsetup[lstlisting]{labelformat=empty, justification=raggedright, singlelinecheck=false}
\begin{lstlisting}[language=c, caption={Syntax}]
	if (condition) {
		// code executed if true
	} else {
		// code executed if false
	}
\end{lstlisting}
}

Example:
\begin{lstlisting}[language=c]
#include <stdio.h>

int main() {
	int number = -5;

	if (number > 0) {
		printf("Number %d is positive\n", number);
	}
	else {
		printf("Number %d is not positive\n", number);
	}

	return 0;
}
\end{lstlisting}
\begin{verbatim}
Output:
Number -5 is not positive
\end{verbatim}

\subsection{if-else if Statement}

The \verb|else if| statement specifies a new condition if the previous condition is false.  
This is useful when multiple conditions with different outcomes exist.

{
\captionsetup[lstlisting]{labelformat=empty, justification=raggedright, singlelinecheck=false}
\begin{lstlisting}[language=c, caption={Syntax}]
	if (condition1) {
		// code executed if condition1 is true
	} else if (condition2) {
		// code executed if condition1 is false and condition2 is true
	} else {
		// code executed if all above conditions are false
	}
\end{lstlisting}
}

Example:
\begin{lstlisting}[language=c]
#include <stdio.h>

int main() {
	int number = -3;

	if (number > 0) {
		printf("Number %d is positive\n", number);
	}
	else if(number < 0){
		printf("Number %d is negative\n", number);
	}
	else{
		printf("Number %d is 0\n", number);
	}

	return 0;
}
\end{lstlisting}
\begin{verbatim}
Output:
Number -3 is negative
\end{verbatim}

\subsection{Nested if}

Nested \verb|if| means placing an \verb|if| statement inside another \verb|if| statement.

Example:
\begin{lstlisting}[language=c]
#include <stdio.h>

int main() {
	int number = 3;

	if (number > 0) {
		if(number % 2 == 0){
			printf("Number %d is even");
		}
		else{
			printf("Number %d is odd");
		}
	}
	else{
		printf("Number %d is not positive");
	}

	return 0;
}
\end{lstlisting}
\begin{verbatim}
Output:
Number 3 is odd
\end{verbatim}

\subsection{Conditional Operator}

The conditional operator can be used as a shorthand for \verb|if| statements, reducing multiple lines to one:

{
\captionsetup[lstlisting]{labelformat=empty, justification=raggedright, singlelinecheck=false}
\begin{lstlisting}[language=c, caption={Syntax}]
    variable = condition ? value_if_true : value_if_false;
\end{lstlisting}
}

Example 1:

Using \verb|if|:
\begin{lstlisting}[language=c]
	int number = 4;
	if (number % 2 == 0) {
		printf("Even");
	} else {
		printf("Odd");
	}
\end{lstlisting}

Using the conditional operator:
\begin{lstlisting}[language=c]
	int number = 4;
	(number % 2 == 0) ? printf("Even") : printf("Odd");
\end{lstlisting}

Example 2:

Using \verb|if|:
\begin{lstlisting}[language=c]
	int a = 5, b = 3, max;

	if(a > b){
		max = a;
	} else{
		max = b;
	}

	printf("The largest value is: %d\n", max);
\end{lstlisting}

Using conditional operator:
\begin{lstlisting}[language=c]
	int a = 5, b = 3, max;

	max = (a > b) ? a : b;

	printf("The largest value is: %d\n", max);

	return 0;
\end{lstlisting}

\subsection{Switch Statement}

The \verb|switch| statement is an alternative to \verb|if-else if|.  
It is useful when you have a single variable with limited discrete values (like \verb|int| or \verb|char|) and want to execute one of several alternative code blocks.

{
\captionsetup[lstlisting]{labelformat=empty, justification=raggedright, singlelinecheck=false}
\begin{lstlisting}[language=c, caption={Syntax}]
	switch (expression) {
		case x:
			// code executed if expression equals x
			break;
		case y:
			// code executed if expression equals y
			break;
		default:
			// code executed if expression does not match any case
	}
\end{lstlisting}
}

Example:
\begin{lstlisting}[language=c]
int day = 4;

switch (day) {
	case 1:
		printf("Monday");
		break;
	case 2:
		printf("Tuesday");
		break;
	case 3:
		printf("Wednesday");
		break;
	case 4:
		printf("Thursday");
		break;
	case 5:
		printf("Friday");
		break;
	case 6:
		printf("Saturday");
		break;
	case 7:
		printf("Sunday");
		break;
}
\end{lstlisting}
\begin{verbatim}
Output:
Thursday
\end{verbatim}

\subsection*{Pre-Lab Assignment 1}
\begin{enumerate}
    \item When writing an \verb|if-else if| statement, the order of conditions can affect program execution. Why? What happens if the order is wrong? Give an example!
    \item Write a program that receives input of three integers A, B, and C. Output the three numbers in descending order. Use \verb|if|, \verb|if-else|, \verb|if-else if|, or nested \verb|if| statements.
    \item Observe the following code:
    \begin{lstlisting}[language=c]
	float number = 3.14;
	switch(number) {
		case 3.14:
			printf("Pi\n");
			break;
	}
\end{lstlisting}
    What happens when this code runs? Why does it happen?
\end{enumerate}

\section{Looping}

Looping is the process of executing a block of code repeatedly as long as a certain condition is met.  
The purpose is to avoid writing repetitive code manually.

\subsection{while Loop}

The \verb|while| loop keeps executing its code as long as the condition is true.

{
\captionsetup[lstlisting]{labelformat=empty, justification=raggedright, singlelinecheck=false}
\begin{lstlisting}[language=c, caption={Syntax}]
	while(condition){
		// code executed repeatedly while condition is true
	}
\end{lstlisting}
}
Example:
\begin{lstlisting}[language=c]
	int i = 0;
	
	while (i < 10) {
		printf("%d\n", i);
		i++;
	}
\end{lstlisting}
\begin{verbatim}
Output:
0
1
2
3
4
5
6
7
8
9
\end{verbatim}
In this example, the code repeats while the value of i is less than 10.  
When i reaches 10, the loop stops.

\subsection{do-while Loop}

The \verb|do-while| loop is similar to \verb|while|, but the code block runs once before checking the condition.

{
\captionsetup[lstlisting]{labelformat=empty, justification=raggedright, singlelinecheck=false}
\begin{lstlisting}[language=c, caption={Syntax}]
	do{
		// code executed once, then check if it should run again
	} while(condition);
\end{lstlisting}
}
Example:
\begin{lstlisting}[language=c]
	int i = 3;

	do {
		printf("%d\n", i);
		i++;
	}
	while (i < 3);
\end{lstlisting}
\begin{verbatim}
Output:
3
\end{verbatim}
In this example, the output is 3 even though the condition i<3 is false, because the code runs once before the condition is checked.

\subsection{for Loop}

The \verb|for| loop is used when we know how many times the loop should run.

{
\captionsetup[lstlisting]{labelformat=empty, justification=raggedright, singlelinecheck=false}
\begin{lstlisting}[language=c, caption={Syntax}]
	for (expression1; expression2; expression3) {
		// code to be repeated
	}
\end{lstlisting}
}

The above syntax can also be written as a \verb|while| loop:

{
\captionsetup[lstlisting]{labelformat=empty, justification=raggedright, singlelinecheck=false}
\begin{lstlisting}[language=c, caption={Syntax}]
	expression1;
	while(expression2){
		// code block to be repeated
		expression3;
	}
\end{lstlisting}
}

\begin{enumerate}[label={}, leftmargin=*]
	\item expression1: executed once before the loop starts
	\item expression2: the condition that must be met for the loop to continue
	\item expression3: executed at the end of each iteration
\end{enumerate}
Example 1:
\begin{lstlisting}[language=c]
	for (int i = 0; i < 5; i++) {
		printf("%d\n", i);
	}
\end{lstlisting}
\begin{verbatim}
Output:
0
1
2
3
4
\end{verbatim}
Example 2:
\begin{lstlisting}[language=c]
	for (int i = 0; i <= 10; i = i + 2) {
		printf("%d\n", i);
	}
\end{lstlisting}
\begin{verbatim}
Output:
0
2
4
6
8
10
\end{verbatim}

\subsection{Nested Loop}

A nested loop is a loop inside another loop.
Example:
\begin{lstlisting}[language=c]
	for (int i = 0; i < 3; i++) {
		for (int j = 0; j < 2; j++) {
			printf("i = %d, j = %d\n", i, j);
		}
	}
\end{lstlisting}
\begin{verbatim}
Output:
i = 0, j = 0
i = 0, j = 1
i = 1, j = 0
i = 1, j = 1
i = 2, j = 0
i = 2, j = 1
\end{verbatim}

The outer loop using variable "i" runs 3 times.  
The inner loop using variable "j" runs 2 times.  
For each iteration of "i", the "j" loop runs completely.  

\subsection{Break and Continue}

\subsubsection{Break}

The \verb|break| statement can exit a \verb|switch| or a loop, stopping it prematurely.
Example:
\begin{lstlisting}[language=c]
	for (int i = 0; i < 5; i++) {
		if (i == 3) {
			break;  
		}
		printf("%d ", i);
	}
\end{lstlisting}
\begin{verbatim}
Output:
0 1 2
\end{verbatim}

\subsubsection{Continue}

The \verb|continue| statement skips the current iteration but continues with the next iteration.
Example:
\begin{lstlisting}[language=c]
	for (int i = 0; i < 5; i++) {
		if (i == 3) {
			continue;
		}
		printf("%d ", i);
	}
\end{lstlisting}
\begin{verbatim}
Output:
0 1 2 4
\end{verbatim}

\subsection*{Pre-Lab Assignment 2}
\begin{enumerate}
	\item Observe the following code:
	\begin{lstlisting}[language=c]
	for(;;){
		printf("B300 MIOT\n");
	}	
\end{lstlisting}
	What happens if this program runs? Why?
	
	\item Observe these two codes:
	\begin{lstlisting}[language=c]
	for(int i=0;i<100;i++){
		break;
	}
\end{lstlisting}
	\begin{lstlisting}[language=c]
	for(int i=0;i<100;i++){
		continue;
	}
\end{lstlisting}
	What happens when each runs?  
	If you had to choose, which code would you pick and why?
	
	\item Observe the following code:
	\begin{lstlisting}[language=c]
	for(int i=0;i<10;i++){
		for(int j=i;j>=0;j--){
			printf("B300\n");
		}
	}
\end{lstlisting}
	When the loop runs, how many times will "B300" appear in the output?
	
	\item Write a C program to print all perfect squares between 1 and 100.
\end{enumerate}

\section{Array}

An array is a collection of data with the same data type stored in a contiguous block of memory.  
With arrays, we can store many data items without creating multiple separate variables.  
To declare an array, we use a syntax similar to declaring a variable:

{
\captionsetup[lstlisting]{labelformat=empty, justification=raggedright, singlelinecheck=false}
\begin{lstlisting}[language=c, caption={Syntax}]
	data_type name[size];
\end{lstlisting}
}
Example:
\begin{lstlisting}[language=c]
	int angka[5]; // array with 5 integers
	float nilai[10]; // array with 10 floats
	char huruf[20]; // array with 20 characters
\end{lstlisting}

\subsection{Array Initialization}

We can initialize an array when declaring it, just like a variable.  
Elements in an array must have the same data type.

\begin{lstlisting}[language=c]
	int angka[5] = {1, 3, 5, 7, 9};
\end{lstlisting}

If initialized at declaration, we can omit the size.  
The compiler automatically adjusts the size according to the number of elements initialized.

\begin{lstlisting}[language=c]
	int angka[] = {1, 4, 7, 10, 13, 16};
\end{lstlisting}

The array above automatically has size 6.

\subsection{Accessing Array Elements}

To access elements in an array, we use the array name and the index of the element.
Example:
\begin{lstlisting}[language=c]
	int angka[5] = {10, 20, 30, 40, 50};

	printf("%d\n", angka[0]); // access element at index 0
\end{lstlisting}

Remember: array indexing starts at 0, so in the example above, 10 is at index 0, 20 is at index 1, etc.

\subsection{Modifying Array Elements}

To modify an element in an array, access the element and assign a new value:

\begin{lstlisting}[language=c]
	int angka[5] = {10, 20, 30, 40, 50};
	
	angka[0] = 15; // change index 0 to 15
	
	printf("%d\n", angka[0]);
\end{lstlisting}

\subsection{Looping Through Arrays}

We can use loops to access each element sequentially.
Example:
\begin{lstlisting}[language=c]
	int angka[5] = {1, 2, 3, 4, 5};

	for(int i = 0; i < 5; i++) {
		printf("angka[%d] = %d\n", i, angka[i]);
	}
\end{lstlisting}
\begin{verbatim}
Output:
angka[0] = 1
angka[1] = 2
angka[2] = 3
angka[3] = 4
angka[4] = 5
\end{verbatim}

\subsection{Array Size}

The size of an array is the number of elements it can store.  
We can get the size of an array using \verb|sizeof()|.
Example:
\begin{lstlisting}[language=c]
	int angka[5] = {2, 4, 8, 12, 16};
	
	int size = sizeof(angka)/sizeof(angka[0]); // get size of array
	printf("%d", size);
\end{lstlisting}

We can use \verb|sizeof()| in loops, so the loop works with any array size.

\begin{lstlisting}[language=c]
	int angka[5] = {2, 4, 8, 12, 16};

	int size = sizeof(angka)/sizeof(angka[0]);
	for(int i=0;i<size;i++){
		printf("%d ", angka[i]);
	}
\end{lstlisting}

\subsection{Multidimensional Arrays}

So far, we have learned 1D arrays.  
Simply put, a multidimensional array is an array inside an array.  
They are usually used to store data requiring more than one index, such as tables with rows and columns.

To declare a multidimensional array:
{
\captionsetup[lstlisting]{labelformat=empty, justification=raggedright, singlelinecheck=false}
\begin{lstlisting}[language=c, caption={Syntax}]
	int name[size_1][size_2]...[size_n];
\end{lstlisting}
}

\subsubsection{2D Array}

Also called a matrix (has rows and columns).

\begin{enumerate}[label={}, leftmargin=*]
	\item \textbf{Accessing 2D Array Elements}\\
	Access a 2D array like a 1D array:

	\begin{lstlisting}[language=c]
	int matrix[2][3] = { {1, 4, 2}, {3, 6, 8} };

	printf("%d", matrix[0][2]);  // output: 2
	\end{lstlisting}
	
	\item \textbf{Modifying 2D Array Elements}
	\begin{lstlisting}[language=c]
	int matrix[2][3] = { {1, 4, 2}, {3, 6, 8} };

	matrix[0][2] = 5;

	printf("%d", matrix[0][2]);  // output: 5
	\end{lstlisting}
	
	\item \textbf{Looping Through a 2D Array}\\
	Use nested loops:

	\begin{lstlisting}[language=c]
	int matrix[2][3] = { {1, 4, 2}, {3, 6, 8} };

	int i, j;
	for (i = 0; i < 2; i++) {
		for (j = 0; j < 3; j++) {
			printf("%d\n", matrix[i][j]);
		}
	}
	\end{lstlisting}
\end{enumerate}

\subsubsection{3D Array}

A 3D array can be imagined as a stack of 2D matrices.  
We need 3 indices to access an element.  
3D arrays are usually used for data with 3-dimensional coordinates.

Example:
\begin{lstlisting}[language=c]
	int cube[2][2][2] = {
		{ {1, 2}, {3, 4} },
		{ {5, 6}, {7, 8} }
	};
\end{lstlisting}

Accessing and modifying elements in a 3D array is the same as for normal arrays.

\subsection*{Pre-Lab Assignment 3}
\begin{enumerate}
	\item Observe the code:
	\begin{lstlisting}[language=c]
	int arr[5] = {1, 2, 3, 4, 5};

	printf("%d", arr[-1]);
\end{lstlisting}
	What happens when this code runs? Explain why.
	
	\item Observe the code:
	\begin{lstlisting}[language=c]
	int arr[3] = {0};
	
	printf("%d", arr[3]);
\end{lstlisting}
	What happens when this code runs? Explain why.
	
	\item Write a simple C program that stores numbers from 1 to 1000 in an array.
\end{enumerate}

\section{String}

A string is a data type used to store text/characters.  
For example, \verb|"Halo Dunia"| is a string.  
In C, a string is an array of characters ending with \verb|\0| (null character).

Example:
\begin{lstlisting}[language=c]
	char kata[] = "Halo Dunia";
\end{lstlisting}

Note that strings are written using double quotes ("").

\subsection{String Input and Output}

We can use \verb|printf()| and \verb|scanf()| with the \verb|%s| specifier.

Example 1:
\begin{lstlisting}[language=c]
	char kata[] = "Halo Dunia";

	printf("%s\n", kata);
\end{lstlisting}
\begin{verbatim}
	Output:
	Halo Dunia
\end{verbatim}

Example 2:
\begin{lstlisting}[language=c]
	char nama[20];

	scanf("%s", nama); // input without spaces

	printf("Halo, %s!\n", nama);
\end{lstlisting}
\begin{verbatim}
	Output:
	B300
	Halo, B300!
\end{verbatim}

Using \verb|scanf("%s", ...);| only allows input without spaces.  
So if you input "B300 MIoT", only "B300" is read.  

To input multiple words (with spaces), we can use:
\verb|scanf("%[^\n]s", str)|, which reads until the end of the line.

Example:
\begin{lstlisting}[language=c]
	char str[20];

	scanf("%[^\n]s", str);

	printf("%s", str);
\end{lstlisting}
\begin{verbatim}
	Input:
	B300 MIoT

	Output:
	B300 MIoT
\end{verbatim}

Alternatively, we can use \verb|fgets()| to read a full line:
\begin{lstlisting}[language=c]
	char str[20];

	fgets(str, sizeof(str), stdin);

	printf("%s", str);
\end{lstlisting}
\begin{verbatim}
	Input:
	B300 luar biasa

	Output:
	B300 luar biasa
\end{verbatim}

\subsection{String Functions}

C provides several string functions for performing operations on strings.  
To use them, include the header:
\begin{lstlisting}[language=c]
	#include <string.h>
\end{lstlisting}

\subsubsection{strlen()}

Used to get the length of a string.

Example:
\begin{lstlisting}[language=c]
	char string[] = "B300";

	printf("%d", strlen(string));
\end{lstlisting}
\begin{verbatim}
	Output:
	4
\end{verbatim}

\subsubsection{strcpy()}

Used to copy a string into another string variable.

Example:
\begin{lstlisting}[language=c]
	char src[] = "miot";
	char dest[20];
	
	strcpy(dest, src);  // copy "miot" to dest
	printf("%s", dest);
\end{lstlisting}
\begin{verbatim}
	Output:
	miot
\end{verbatim}

\subsubsection{strcat()}

Used to concatenate two strings.

Example:
\begin{lstlisting}[language=c]
	char s1[30] = "B300 ";
	char s2[] = "MIoT";
	
	strcat(s1, s2); // concatenate "B300 " with "MIoT"
	printf("%s", s1);
\end{lstlisting}
\begin{verbatim}
	Output:
	B300 MIoT	
\end{verbatim}

\subsubsection{strcmp()}

Used to compare two strings.  
Returns 0 if the strings are equal.

Example:
\begin{lstlisting}[language=c]
	char s1[] = "Apple";
	char s2[] = "Apple";
	
	int res = strcmp(s1, s2);

	if(res==0){
		printf("The strings are equal");
	}
	else{
		printf("Strings are different");
	}
\end{lstlisting}

Many more string functions can be explored in the <string.h> documentation.

\subsection*{Pre-Lab Assignment 4}
\begin{enumerate}
	\item Why must strings in C have a null character '\verb|\0|'? What happens if a string does not have a null character?
	\item Observe the code:
	\begin{lstlisting}[language=c]
	char lab[] = {'B', '3', '0', '0', ' ', 'M', 'I', 'O', 'T', '\0'};
	
	for(int i=0;i<sizeof(lab);i++){
		printf("%c", lab[i]);
	}	
	\end{lstlisting}
	Try running this code. What do you think about it? Is it efficient?
	\item Write a simple program that accepts input for \verb|nama_lengkap|, \verb|NRP|, and \verb|password|.  
	Check if the password is "B300 MIOT".  
	If correct, output:
	\begin{verbatim}
		Halo, full_name with NRP
		You have logged in
	\end{verbatim}
	If incorrect, output:
	\begin{verbatim}
		Halo, full_name with NRP
		You cannot log in
	\end{verbatim}
\end{enumerate}
