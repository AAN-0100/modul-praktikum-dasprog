\section*{Goals}
\begin{itemize}[label=$\bullet$, itemsep=-1pt, leftmargin=*]
    % \item Mahasiswa mengerti tentang konsep pointer pada bahasa pemrograman C.
    \item Students are able to understand the concept of pointers in C.
          % \item Mahasiswa mengerti cara membuat dan memanggil struct pada bahasa pemrograman C.
    \item Students are able to create and call a struct in C.
          % \item Mahasiswa mengerti tentang algoritma sorting pada bahasa pemrograman C.
    \item Students are able to understand about sorting algorithm in C.
          % \item Mahasiswa mengerti tentang algoritma searching pada bahasa pemrograman C.
    \item Students are able to understand about searching algorithm in C.
          % \item Mahasiswa mampu mengaplikasikan konsep algoritma searching dan sorting pada bahasa pemrograman C.
    \item Students are able to apply the conceptof searching and sorting algorithm in C.
\end{itemize}

\section{Pointer}

A pointer is a variable that stores the memory address of another variable.
A variable created in C occupies a space in memory, and this space has an address called a memory address.
We can obtain the memory address using the \& operator. \\
Example:
\begin{lstlisting}[language=c]
	int a = 10;
	printf("%d\n", a); // output 10
	printf("%p\n", &a); // output the address of variable a
\end{lstlisting}

\subsection{Declaration and Initialization}

To declare a pointer, it is similar to declaring a variable but with a * after the data type
{
\captionsetup[lstlisting]{labelformat=empty, justification=raggedright, singlelinecheck=false} %caption without label and aligned left
\begin{lstlisting}[language=c, caption={Syntax}]
	data_type *name;
\end{lstlisting}
}
To initialize, assign it the address of another variable.
Example:
\begin{lstlisting}[language=c]
	int number;
	int *ptr = &number; // initialize pointer ptr to point to number

	printf("%p\n", &number); // output address of number
	printf("%p\n", ptr);    // output address of number
\end{lstlisting}

\subsection{Dereference}

Dereference is the term used to get the value of the variable pointed to by a pointer.
Example:
\begin{lstlisting}[language=c]
	int number = 10;
	int *ptr = &number;

	printf("%d\n", number); // output value of number
	printf("%d\n", *ptr);  // output value of number
\end{lstlisting}
\begin{verbatim}
	Output:
	10
	10
\end{verbatim}

\subsection{Pointer with Variables}

Using a pointer, we can access a variable without calling the variable itself.
We only need to call the pointer.
Example:
\begin{lstlisting}[language=c]
	int number = 5;
	int *ptr = &number;

	printf("%d\n", number);

	*ptr = 15; // access the variable number using the pointer

	printf("%d\n", number);  
\end{lstlisting}
\begin{verbatim}
    Output:
    5
    15
\end{verbatim}
In the example above, the variable \texttt{number} is accessed using the pointer \texttt{ptr}, so its value changes.

\subsection{Pointer with Arrays}

Pointers can also store the memory address of an array.
In C, the name of an array stores the address of its first element.
Example:
\begin{lstlisting}[language=c]
	int arr[5] = {10, 20, 30, 40, 50};
	printf("%p\n", arr);     // address of first element (arr[0])
	printf("%p\n", &arr[0]); // address of first element (arr[0])
\end{lstlisting}
Thus, the name of an array can be considered as a pointer pointing to the first element of the array.
Example of accessing the first element:
\begin{lstlisting}[language=c]
	int arr[5] = {10, 20, 30, 40, 50};
	printf("%d\n", arr[0]); // access first element
	printf("%d\n", *arr);   // access first element    
\end{lstlisting}
\begin{verbatim}
    Output:
    10
    10
\end{verbatim}
To access the next elements, simply increment the pointer:
\begin{lstlisting}[language=c]
	int arr[5] = {10, 20, 30, 40, 50};
	printf("%d\n", *(arr+1)); // access second element
	printf("%d\n", *(arr+2)); // access third element    
\end{lstlisting}
\begin{verbatim}
    Output:
    20
    30
\end{verbatim}
We can also use a loop:
\begin{lstlisting}[language=c]
	int arr[5] = {10, 20, 30, 40, 50};
	for(int i=0;i<5;i++){
		printf("%d\n", *(arr+i));
	}
\end{lstlisting}    
\begin{verbatim}
	Output:
	10
	20
	30
	40
	50
\end{verbatim}
Pointers can also modify the values of an array:
\begin{lstlisting}[language=c]
	int arr[3] = {1, 2, 3};
	int *ptr = arr; // pointer pointing to arr

	*(ptr+1) = 4; // change value at arr index 1

	printf("%d\n", arr[1]);
\end{lstlisting}
\begin{verbatim}
	Output:
	4
\end{verbatim}

\subsection{Pointer and Functions}

Using pointers, we can pass a variable from outside a function and modify its value inside the function.
This is called passing parameters by reference, whereas passing arguments normally is called passing parameters by value.

\subsubsection{Passing by Value}

By default, a C function only sends the value of an argument to the parameter inside the function.
So even if the values are the same, the variables are different.
Example:

\begin{lstlisting}[language=c]
#include <stdio.h>

void change(int x) {
	printf("%d ", x);
	x = 20;   // modify local variable x
	printf("%d\n", x);
}

int main() {
	int a = 10;
	change(a);
	printf("%d\n", a);
}
\end{lstlisting}
\begin{verbatim}
	Output:
	10 20
	10
\end{verbatim}
From the example above, the value of variable \texttt{a} remains 10, even though variable \texttt{x} changed.
This is because only the value 10 is sent into the function and copied to variable \texttt{x}, not the variable \texttt{a} itself.

\subsubsection{Passing by Reference}

Used to modify a variable outside the function using a pointer.
Example:
\begin{lstlisting}[language=c]
#include <stdio.h>

void change(int *x) { // parameter is a pointer
	*x = 20;   // change the value at address x
}

int main() {
	int a = 10;
	change(&a);   // send address of a
	printf("%d\n", a);
}
\end{lstlisting}
\begin{verbatim}
	Output:
	20
\end{verbatim}
From the example above, the value of \texttt{a} changes even though the modification is inside the function because passing by reference is used.
This can be used to create a function that swaps the values of two variables:
\begin{lstlisting}[language=c]
#include <stdio.h>

void swap(int *x, int *y) {
	int temp = *x;
	*x = *y;
	*y = temp;
}

int main() {
	int a = 5, b = 10;
	swap(&a, &b);
	printf("a = %d, b = %d\n", a, b);
}
\end{lstlisting}
\begin{verbatim}
	Output:
	a = 10, b = 5
\end{verbatim}
Passing by reference can also be used to pass an array as a function parameter.
Example:
\begin{lstlisting}[language=c]
void printArray(int *arr, int n) { // pointer as parameter for array
	for (int i = 0; i < n; i++) {
		printf("%d ", *(arr + i));
	}
	printf("\n");
}

int main() {
	int data[5] = {1, 2, 3, 4, 5};
	printArray(data, 5); // pass array to function
}
\end{lstlisting}
\begin{verbatim}
    Output:
    1 2 3 4 5     
\end{verbatim}

\subsection*{Pre-lab Assignment 1}
\begin{enumerate}
    \item What are the uses of pointers? Explain!
    \item How do you declare a pointer to a multidimensional array?
    \item Consider the following code:
    \begin{lstlisting}[language=c]
#include <stdio.h>

int main() {
	int arr[4] = {25, 50, 75, 100};

	for (int i = 0; i < 4; i++) {
		printf("%d\n", *(arr++));
	}
}
\end{lstlisting}
    The code above contains an error. Why does this error occur? What is the solution?
    \item Explain what you know about pointers to pointers! Give an example of its usage!
    \item Study sorting algorithms! Write down what you have learned!
\end{enumerate}

\section{Struct}

Struct is a way to group several variables (which can be of different types) into one.
If an array can store many data of the same type, a struct can store various types of data.
Example:
\begin{lstlisting}[language=c]
#include <stdio.h>

struct Student {
	int nrp;
	char name[50];
	float gpa;
};

int main() {
	struct Student s1 = {5024991000, "B300", 3.99};

	printf("NRP   : %d\n", s1.nrp);
	printf("Name : %s\n", s1.name);
	printf("GPA  : %.2f\n", s1.gpa);

	return 0;
}
\end{lstlisting}

\subsection{Creating a Struct}

To create a struct, we use the keyword \texttt{struct}:
{
\captionsetup[lstlisting]{labelformat=empty, justification=raggedright, singlelinecheck=false} % caption without label and aligned left
\begin{lstlisting}[language=c, caption={syntax}]
	struct Coord {
		int x;
		int y;
	};
\end{lstlisting}
}
Don't forget to add a semicolon at the end of the braces.\\\\
To access a struct, we need to declare a variable for that struct.
To access a member of a struct, we call the variable, then use a dot followed by the member name.
Example:
\begin{lstlisting}[language=c]
	struct Coord {
		int x;
		int y;
	};

	int main(){
		struct Coord p1 = {10, 20}; // create struct variable

		printf("%d %d\n", p1.x, p1.y); // access members of p1

		p1.x = 30; // modify member of p1
		printf("%d %d\n", p1.x, p1.y);
	}    
\end{lstlisting}
\begin{verbatim}
    Output:
    10 20
    30 20    
\end{verbatim}

\subsection{Struct and Pointer}

A pointer can be used to point to a struct, and access its members using the arrow operator (->).
Example:
\begin{lstlisting}[language=c]
	struct Coord {
		int x;
		int y;
	};

	int main(){
		struct Coord p1 = {10, 20};
		struct Coord *ptr = &p1;
		
		printf("%d %d\n", ptr->x, ptr->y);
	}
\end{lstlisting}
\begin{verbatim}
    Output:
    10 20   
\end{verbatim}

\subsection{Array of Structs}

A struct can be used as an array.
Example:
\begin{lstlisting}[language=c]
	struct Student {
		char nrp[20];
		char name[50];
		float gpa;
	};
	
	int main() {
		struct Student students[2] = {
			{"5024991001", "student1", 3.1},
			{"5024991002", "student2", 3.2}
		};
	
		for (int i = 0; i < 2; i++) {
			printf("%s %s %.2f\n", students[i].nrp, students[i].name, students[i].gpa);
		}
	}
\end{lstlisting}
\begin{verbatim}
    Output:
    5024991001 student1 3.10
    5024991002 student2 3.20
\end{verbatim}

\subsection{Nested Struct}

A nested struct is a struct that has a member which is another struct.
This is useful when the stored data has a hierarchy.
Example:
\begin{lstlisting}[language=c]
#include <stdio.h>

// Address struct
struct Address {
	char street[50];
	char city[30];
};

// Student struct containing Address struct
struct Student {
	char nrp[20];
	char name[50];
	float gpa;
	struct Address address;  // nested struct
};

int main() {
	struct Student s1 = {
		"5024991000", "B300", 3.8,
		{"ITS Main Street", "Surabaya"}
	};

	printf("NRP      : %s\n", s1.nrp);
	printf("Name    : %s\n", s1.name);
	printf("GPA     : %.2f\n", s1.gpa);
	printf("Address : %s, %s\n",
		s1.address.street,
		s1.address.city);

	return 0;
}
\end{lstlisting}
\begin{verbatim}
    Output:
    NRP     : 5024991000
    Name    : B300
    GPA     : 3.80
    Address : ITS Main Street, Surabaya
\end{verbatim}

\subsection{Typedef Struct}

Using \texttt{typedef} allows us to write struct declarations more concisely.
Example:
\begin{lstlisting}[language=c]
	typedef struct { // Create struct with typedef
		char nrp[20];
		char name[50];
		float gpa;
	} Student;

	int main(){
		Student s1 = {"5024991000", "B300", 3.99}; // declare struct variable without writing struct Student

		printf("NRP   : %d\n", s1.nrp);
		printf("Name : %s\n", s1.name);
		printf("GPA  : %.2f\n", s1.gpa);
		
		return 0;
	}
\end{lstlisting}

\subsection*{Pre-lab Assignment 2}
\begin{enumerate}
    \item Can a struct be used as a function parameter? How?
    \item What is a union? How is it different from a struct? Explain!
    \item If there are three data values, which are assignment score, midterm score, and final exam score.
    These three values can be stored as integers.
    In your opinion, is it better to store these three values as an array or a struct? Explain your answer!
\end{enumerate}
