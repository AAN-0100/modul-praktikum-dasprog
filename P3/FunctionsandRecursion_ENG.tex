% \chapter{Fungsi (Subprogram)}
% \section{Tujuan}
\section*{Goals}
\begin{itemize}[label=$\bullet$, itemsep=-1pt, leftmargin=*]
    \item Students are able to create and call functions in C .
          % \item Mahasiswa mengerti cara membuat dan memanggil fungsi pada bahasa pemrograman C.
    \item Students are able to pass parameter by value and by reference in C.
          % \item Mahasiswa mampu menggunakan passing parameter by value dan by reference pada bahasa pemrograman C.
    \item Students understand and are able to apply recursion in C.
          % \item Mahasiswa mampu mengerti dan mengaplikasikan konsep rekursi pada bahasa pemrograman C.

\end{itemize}

\section{Functions}

A function is a named block of code created to perform a specific task.  
Functions help make programs more modular, organized, and easier to maintain.  
Each function can be called repeatedly from any part of the program without rewriting the code.
\\\\Benefits of Functions:
\begin{enumerate}
    \item \textbf{Reduce Code Duplication} \\  
    If a command is used repeatedly, it only needs to be written once in a function.  
    It can then be called whenever needed.
    
    \item \textbf{Improve Readability and Program Structure} \\  
    Programs with functions are easier to read and understand because they are organized.  
    Function names can describe their tasks.
    
    \item \textbf{Ease Maintenance} \\  
    If changes are needed, just update the relevant function without modifying the entire program.
    
    \item \textbf{Reusability} \\  
    Functions can be reused in other programs with little or no modification.
    
    \item \textbf{Ease of Debugging and Testing} \\  
    Errors are easier to trace because functions can be tested individually.
\end{enumerate}
Functions can be classified into two types:
\begin{enumerate}
    \item \textbf{Library (Predefined) Functions} \\  
    Functions that are already available in C, like \verb|main()|, \verb|printf()|, and \verb|scanf()|.  
    These come from libraries included via headers like \verb|#include <stdio.h>|.
    
    \item \textbf{User-Defined Functions} \\  
    Functions created by the programmer as needed.
\end{enumerate}

\subsection{Creating a Function}

To create a function:
{
\captionsetup[lstlisting]{labelformat=empty, justification=raggedright, singlelinecheck=false}
\begin{lstlisting}[language=c, caption={syntax}]
	return_type function_name(parameters){
		// code executed when the function is called
	}
\end{lstlisting}
}

\begin{enumerate}[label={}, leftmargin=*]
    \item \verb|return_type|: data type of the return value (use \verb|void| if no return value).  
    \item \verb|function_name|: the name of the function.  
    \item \verb|parameters|: values or variables passed into the function.
\end{enumerate}

\subsubsection{Declaration and Definition}

A function has two parts:
\begin{itemize}
    \item \textbf{Declaration}: specifies return type, function name, and parameters.  
    \item \textbf{Definition}: contains the code executed when the function is called.
\end{itemize}

Example:
\begin{lstlisting}[language=c]
	void myFunction(int number){ // Declaration
		// code (Definition)
	}
\end{lstlisting}

Declarations and definitions can be written together, or separately for readability.  
Example of separate declaration and definition:
\begin{lstlisting}[language=c]
	// Declaration
	void myFunction(int number);

	// main function
	int main(){
		// code
	}

	// Definition
	void myFunction(int number){
		// code
	}
\end{lstlisting}

\subsection{Calling a Function}

To use a function, simply call it using its name and parentheses \verb|()|.  
Example:
\begin{lstlisting}[language=c]
	void greet(){
		printf("Hello World!");
	}

	int main(){
		greet();
		return 0;
	}
\end{lstlisting}
\begin{verbatim}
    Output:
    Hello World!
\end{verbatim}

A function can be called multiple times:
\begin{lstlisting}[language=c]
	void greet(){
		printf("Hello World!\n");
	}

	int main(){
		greet();
		greet();
		greet();
		return 0;
	}
\end{lstlisting}
\begin{verbatim}
	Output:
	Hello World!
	Hello World!
	Hello World!
\end{verbatim}

\subsection{Parameters and Arguments}

Parameters are variables defined when declaring or defining a function.  
They allow functions to accept external data.

Example:
\begin{lstlisting}[language=c]
	void sum(int a, int b){
		printf("%d", a+b);
	}
\end{lstlisting}

Arguments are values passed to the parameters:
\begin{lstlisting}[language=c]
	void sum(int a, int b){
		printf("%d", a+b);
	}

	int main(){
		sum(10, 5);
		return 0;
	}
\end{lstlisting}
\begin{verbatim}
	Output:
	15
\end{verbatim}

Here, \verb|int a| and \verb|int b| are parameters, and 10 and 5 are arguments.

\subsection{Return Value}

A return value is the result sent by a function to the caller.  
It must match the functionâ€™s return type.  
Functions with \verb|void| type do not return values.  

Example:
\begin{lstlisting}[language=c]
#include <stdio.h>

int add(int a, int b) {
	return a + b;  // returns sum
}

int main(){
	int a = 5, b = 10;
	int sumResult = add(a, b); // store return value
	printf("%d", sumResult);
}
\end{lstlisting}

\subsection{Variable Scope}

Variables have a scope, i.e., where they can be accessed in a program.  
Example:
\begin{lstlisting}[language=c]
	void value(){
		int x = 1;
	}

	int main(){
		value();
		printf("%d", x); // error
		return 0;
	}
\end{lstlisting}
Here, \verb|x| is local to \verb|value()| and cannot be accessed outside it.

\subsubsection{Local Variables}

Local variables are declared inside a function or block and are only accessible within that block.  
Example:
\begin{lstlisting}[language=c]
#include <stdio.h>

int main(){
	int x = 10; // local to main

	if(x>9){
		int y = 10; // local to if-block
		x = 0;     // access x
	}
	printf("%d\n", x); // OK
	printf("%d\n", y); // error
	return 0;
}
\end{lstlisting}

\subsubsection{Global Variables}

Global variables are declared outside all functions and can be accessed anywhere in the program.  
Example:
\begin{lstlisting}[language=c]
#include <stdio.h>

int x = 1; // global

void change(){
	x = 5;
}

int main(){
	printf("%d\n", x); // 1
	x = 2;
	printf("%d\n", x); // 2

	change(); 
	printf("%d\n", x); // 5
	return 0;
}
\end{lstlisting}

\subsubsection{Variable Naming Conflicts}

If a global and a local variable share the same name, they are treated as distinct variables.
Example:
\begin{lstlisting}[language=c]
#include <stdio.h>

int x = 1; // global

void test(){
	int x = 5; // local
	printf("%d\n", x); // prints local
}

int main(){
	test();
	printf("%d\n", x); // prints global
	return 0;
}
\end{lstlisting}
\begin{verbatim}
	Output:
	5
	1
\end{verbatim}

\subsection*{Pre-Lab Assignment 1}
\begin{enumerate}
    \item Explain why functions make programs more efficient and readable!
    \item What is a static variable? Explain its uses!
    \item Give an example problem that is easier to solve using functions!
    \item Write a function that returns the square root of a number! (do not use library functions).
\end{enumerate}

\section{Recursion}

Recursion is a technique where a function calls itself.

\subsection{Structure of Recursion}

Recursion consists of two parts:
\begin{enumerate}
    \item \textbf{Base case} \\
    A condition that stops the recursion.
    It is used to prevent infinite recursion.
    \item \textbf{Recursive case} \\
    The part where the function calls itself.
\end{enumerate}

\subsection{Example of Using Recursion}

\begin{lstlisting}[language=c]
#include <stdio.h>

int factorial(int n) {
	if (n == 0 || n == 1)  // base case
		return 1;
	else                   // recursive case
		return n * factorial(n - 1);
}

int main() {
	printf("5! = %d\n", factorial(5));
	return 0;
}
\end{lstlisting}

The example above shows the use of recursion to calculate the factorial value.  
The function \texttt{factorial(n)} will return the value $n \times \text{factorial}(n-1)$, then \texttt{factorial(n-1)} will return $(n-1) \times \text{factorial}(n-2)$, and so on.  
This process repeats until the base case is reached, i.e., when $n$ is 0 or 1.

\begin{verbatim}
    factorial(n) = n x factorial(n-1)
                 = n x (n-1) x factorial(n-2)
                 = n x (n-1) x (n-2) x factorial(n-3)
                 = n x (n-1) x (n-2) x ... x 2 x factorial(1)
                 = n x (n-1) x (n-2) x ... x 2 x 1
\end{verbatim}

\subsection*{Pre-lab Assignment 2}
\begin{enumerate}
    \item Give an example of a problem that is easier to solve using recursion.
    \item What are the advantages and disadvantages of recursion? Explain.
    \item Consider the following code:
    \begin{lstlisting}[language=c]
	int factorial(int n) {
		if (n == 0 || n == 1)  // base case
			return 1;
		else                   // recursive case
			return n * factorial(n - 1);
	}
\end{lstlisting}
    What happens if we call the function with a negative number as the argument?  
    What solution can you provide?
    \item Study search algorithms! Write down what you have learned.
    \item Which search algorithm is the most efficient and why?
\end{enumerate}
